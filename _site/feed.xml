<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>咖啡不苦</title>
    <description>赖晨东的博客 | 咖啡不苦</description>
    <link>http://laichendong.com/</link>
    <atom:link href="http://laichendong.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 11 Jun 2019 15:45:18 +0800</pubDate>
    <lastBuildDate>Tue, 11 Jun 2019 15:45:18 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>足迹地图</title>
        <description>&lt;div id=&quot;main&quot; style=&quot;width: 700px; height: 500px; &quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/echarts/4.2.1/echarts.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.echartsjs.com/gallery/vendors/echarts/map/js/china.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
window.onload=function(){
	var mydata = [
		{name: '北京',value: 1 },{name: '天津',value: 1 },
	{name: '上海',value: 1 },{name: '重庆',value: 1 },
	{name: '河北',value: 1 },{name: '河南',value: 10 },
	{name: '云南',value: 10 },{name: '辽宁',value: 10 },
	{name: '黑龙江',value: 10 },{name: '湖南',value: 10 },
	{name: '安徽',value: 10 },{name: '山东',value: 1 },
	{name: '新疆',value: 10 },{name: '江苏',value: 1 },
	{name: '浙江',value: 1 },{name: '江西',value: 1 },
	{name: '湖北',value: 1 },{name: '广西',value: 10 },
	{name: '甘肃',value: 10 },{name: '山西',value: 10 },
	{name: '内蒙古',value: 10 },{name: '陕西',value: 1 },
	{name: '吉林',value: 10 },{name: '福建',value: 1 },
	{name: '贵州',value: 10 },{name: '广东',value: 1 },
	{name: '青海',value: 10 },{name: '西藏',value: 10 },
	{name: '四川',value: 1 },{name: '宁夏',value: 10 },
	{name: '海南',value: 10 },{name: '台湾',value: 10 },
	{name: '香港',value: 10 },{name: '澳门',value: 10 }
	];
var option = {
		visualMap: {
			show : false,
			splitList: [ 
				{start: 5, end:10},{start: 1, end: 2}
			],
			color: ['#ccc', '#0f0']
		},
		series: [{
		  type: 'map',
		  mapType: 'china', 
		  roam: false,
		  data:mydata
		}]
	};
var chart = echarts.init(document.getElementById('main'));
chart.setOption(option);
}
&lt;/script&gt;

</description>
        <pubDate>Tue, 11 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/06/11/footprints/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/06/11/footprints/</guid>
        
        
        <category>生活</category>
        
      </item>
    
      <item>
        <title>达到了沟通的目的才算有效沟通</title>
        <description>&lt;h3 id=&quot;wtf我邮件文档里不是写了吗&quot;&gt;WTF，我邮件/文档里不是写了吗？&lt;/h3&gt;

&lt;p&gt;想象一下这个场景是否很常见？周五下午，你把你一周的工作内容和取得的进展都写进了一篇长长的周报，然后发给了领导和相关涉及的同事。但周一还是会有很多人来询问你相关工作的进展和各种情况。这个时候也许你会想：WTF，我邮件里不是都写了吗？&lt;/p&gt;

&lt;p&gt;你的工作进展已经通过邮件发给了相关的人，但对方没看或者看了没get到，进而造成的各种工作不顺，这是谁的问题？这是个问题！我觉得按照”谁受益，谁负责”的原则，这是你的问题！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;沟通的目的是为了传递信息或思想&lt;/strong&gt;，如果作为沟通的发起方，只自顾自的将信息甩出去而不管接收方是否收到并正确理解，并还认为”这不是我的问题”的人就如同自欺欺人+掩耳盗铃。&lt;strong&gt;达到了沟通的目的才算有效沟通&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以，沟通其实一共分两步：1、将信息准确的传递出去；2、确认对方收到并理解无误。TCP作为著名计算机网络的通信协议，整个互联网的基础，就是这么干的。所有的信息传递都有一个确认的过程。很多人会比较容易忽略第二步，其实最简单的实践就是让对方在复述一遍你说的话，如果能正确复述，就ok了，否则，应该继续沟通。&lt;/p&gt;

&lt;h3 id=&quot;为了沟通效果需要使用对方能听懂的语言&quot;&gt;为了沟通效果，需要使用对方能听懂的语言&lt;/h3&gt;

&lt;p&gt;关于这点，中国文化有很多相关的内容。比如：到什么山唱什么歌；见人说人话，见鬼说鬼话；入乡随俗……等等等。描述相反的情形也有很多词：鸡同鸭讲，对牛弹琴……等等等。&lt;/p&gt;

&lt;p&gt;这点作为研发同学尤其要注意，很多研发和人沟通习惯使用太过专业的术语，以至于业务和产品同学无法理解。应时刻谨记沟通的目的是将信息正确的传递到对方的脑袋里，而不是卖弄自己有多少专业知识。&lt;/p&gt;

&lt;p&gt;google曾经有一个著名的面试题，至今值得思考：如何向你80岁的老奶奶说明什么是搜索引擎？&lt;/p&gt;

&lt;h3 id=&quot;说服不是目的沟通才是&quot;&gt;&lt;strong&gt;说服不是目的，沟通才是！&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;还有很多时候，沟通双方持有的观点是冲突的。这时沟通很容易演变成争吵，而沟通双方也很容易陷入到”说服对方”的泥潭里去。想象你和一个人吵架并且吵输了，然后回来你会在心理再吵八百遍，当时这么这么说就好了！看出来了吗？虽然你当时被说的哑口无言，看似被说服了，但对方的思想并没有到你的脑袋里来。&lt;/p&gt;

&lt;p&gt;同样的道理，当我们处于沟通双方比较强势的一方时，需要谨慎的区分对方是被暂时的说服了，被你的淫威压制了，还是真正的你的思想被对方认可了。&lt;/p&gt;
</description>
        <pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/05/16/effective-communication/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/05/16/effective-communication/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>启示录-打造用户喜爱的产品</title>
        <description>&lt;p&gt;《启示录-打造用户喜爱的产品》是Marty Cagan总结20余年软件产品管理经验的作品，作者在惠普，网景，美国在线和eBay负责过产品工作。本书主要就是他工作的一些感悟和总结。如书名，内容非常富有启发性。&lt;/p&gt;

&lt;p&gt;我的日常工作是技术经理，产品经理是我最亲密的合作伙伴。同时，甚至我本身都承担了一部分产品经理的角色。所以这本书对我的帮助也很大。&lt;/p&gt;

&lt;p&gt;全书的形式看起来有点像”文集”，一共41章内容。这些章节互相关联也彼此独立。分为四个部分：”人员”讲的是和产品经理相关的关键角色，以及这些角色之间的区别和界限。”流程”讲了很多产品管理工作中的思考和最佳实践。属于”术”的层面。”产品”则进一步升华上升到了”道”的层面。涉及需求模型，人类情感，以及不同类型产品（大众网络服务，企业级产品，平台型产品）的打造方法。最后一部分”总结”只有两章，最佳实践和反省清单。&lt;/p&gt;

&lt;h3 id=&quot;人员&quot;&gt;人员&lt;/h3&gt;

&lt;p&gt;作者开篇提出”产品是有团队成员设计开发的，选择团队成员、界定工作职责是产品成败的决定因素”。并指出产品经理两项主要职责：评估产品机会和定义要开发的产品。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;交互设计师&lt;/strong&gt;：负责将功能和设计相结合，确保产品同时具有可用性(用户知道怎么用)和价值(用户想要用，能解决问题)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;项目经理&lt;/strong&gt;：负责制定计划和跟踪进度。在小型项目或者长期配合的团队中，可以没有专职的项目经理，有产品经理或开发经理兼任。只有当涉及到大量的协调工作使得计划和进度推进变得复杂时，才有必要引入专门的人员。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开发团队&lt;/strong&gt;：负责开发实现产品。随着DevOps的兴起，运维工作，也可以（应该）由开发团队承担。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;产品营销人员&lt;/strong&gt;：负责对外发布和宣传茶农，如果不是做来对外销售的产品。产品运营人员替代营销人员将是更加普遍的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“如果产品没有市场价值，那么无论开发团队多么优秀也无济于事”&lt;/p&gt;

&lt;p&gt;在产品管理的过程中，应该留一部分时间(20%)给开发保证”架构健康”，防止过了一段时间需要整体”推倒重来”，重新写代码的情况发生，因为一旦这种情况发生，产品的业务需求将很长一段时间得不到满足，市场机会将会错失，甚至产品因此而失败。&lt;/p&gt;

&lt;p&gt;产品管理应该非常重视”用目标进行管理”。产品经理留给用户体验设计师和开发人员的空间越大，他们就越有可能打造出用户喜爱的产品。这里作者应用了巴顿将军的一句名言：”&lt;strong&gt;永远不要告诉别人怎么做，告诉他们做什么，他们自然会发挥天赋，给你惊喜&lt;/strong&gt;”&lt;/p&gt;

&lt;h3 id=&quot;流程&quot;&gt;流程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;评估产品机会&lt;/strong&gt;。是确定待解决的问题是什么以及值不值得用产品的方式来解决的一个工作。在现实中，一般产出一份BRD或MRD的文档。但我们的BRD有很多问题，往往不是在回答”产品要解决什么问题？”而是”用什么方法可以解决这个问题？”。在评估产品机会的过程中，主要要想清楚，要解决什么问题？给谁解决？市场竞争环境和你的竞争优势是什么？时机怎么样？成功的条件是什么？这些问题。如果有”财务思维”，在评估”值不值”的时候会很有帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义正确的产品&lt;/strong&gt;。软件项目分为两个阶段：产品探索(弄清楚要开发什么产品)以及开发他。第一个阶段要大胆假设小心求证。而第二阶段则强调强大的执行力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;产品原则&lt;/strong&gt;是对团队信仰和价值观的总结，用来指导产品团队做出正确的决策和取舍。比如京东的产品原则是”客户为先”，而这个客户被理解为京东的消费者的时候，在退款流程中就会出现”闪退(消费者提出退货请求，在商家收到退货之前先把款项退还给消费者)”这种产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;市场调研&lt;/strong&gt;很重要，他的结果可以用于完善现有产品，但绝对不能用来决定产品研发的方向。世界上伟大产品比如google，iPhone都不是调研出来的。用户在看到真正的产品之前，根本不知道自己要的什么。这里有个很著名的例子。就是当还没汽车的时候，你去做调研，别人只会说”我想要一辆更快的马车！”。这点需要产品经理有很深的洞见，不能用户说什么或者运营说什么，就直接照着做。变成”传话筒”产品经理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消减功能还是延长工期&lt;/strong&gt;？这是个问题。在项目管理里甚至还有一个选项叫做”降低质量”！这真是糟糕透了！作者在这里说明的是这不是一个选择题。没得选，&lt;strong&gt;必须延长工期！但前提是改变设计产品的方法。&lt;/strong&gt; &lt;strong&gt;不再试图定义最终产品，转而定义只满足基本要求的产品，即基本产品（MVP）&lt;/strong&gt;。这个MVP是不可分割的，必须一起完成，否则只能延长工期。这样也能迫使产品经理去思考每个功能的价值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用原型&lt;/strong&gt;，一定要使用高保真原型定义产品，因为第一，迫使产品经理深入定义解决方案，第二，可以让真实的用户参与测试和验证产品创意；第三，可以直观的向团队展示产品的设计思路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;改进现有产品&lt;/strong&gt;，不是一味的添加功能。作者指出了一个很残酷的事实：”大多数产品团队实际上只是功能加工厂，附带制作补丁和修补BUG”。作者给出的解题思路是，第一步是明确产品目标(产品是解决什么问题的)，然后建立指标来衡量问题的解决程度，最后，只有能提高指标的功能才是你关注的重点。而不是简单的满足个别人的需求或对用户调研结果照单全收。&lt;/p&gt;

&lt;h3 id=&quot;产品&quot;&gt;产品&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;苹果公司给我们的启示&lt;/strong&gt;：硬件为软件服务，软件为用户体验服务，用户体验为情感服务，产品为真正的需求服务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提防有特殊要求的产品&lt;/strong&gt;。不要混淆客户需求和产品需求。产品需求不能直接由用户决定。因为一、在看到具体产品之前用户很难知道真正想要什么，二、用户不知道什么样的产品是可行的。三、用户之间很少沟通，需求很难统一。做平台型产品这点很突出。第一次调研大商家要这些需求，第二次调研中小商家又要那些需求，但两次要的需求可能是冲突的。做多边市场型的产品也经常遇到这种问题，比如”急速退款”，这时候应该根据”产品原则”来决策&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;恐惧，贪婪，欲望。&lt;/strong&gt; 消费者购买产品大多源于情感需求。企业级消费者出于恐惧和贪婪购买产品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;情感接纳曲线&lt;/strong&gt;。借鉴《跨越鸿沟》里的技术接纳曲线的概念(技术创新者，尝鲜者，早期消费大众，后期消费大众，跟随者)，对应的 技术爱好者，非理性消费者，理性消费者，超理性消费者和观望者。产品经理应该关注非理性消费者 消费之后发出的”失望，不满，愤怒”这些负面情绪并加以改善，然后使产品跨越鸿沟到扩展到理性消费者群体中去。锤子手机  vs  小米手机。一开始都是小众产品，但小米跨越了鸿沟，不在”只为发烧而生”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可用性与美感&lt;/strong&gt;。作为B端产品，设计是一个被严重忽略的侧面。有篇文章&lt;a href=&quot;http://www.woshipm.com/pd/2183404.html&quot;&gt;《B端产品，远比想象中的需要情感化设计》&lt;/a&gt; 阿里的”店小二”，”灭绝师太”等其实是一种很好的情感设计，我们商家后台也开始尝试，”大促氛围”，”治理哥”这些都取得很好的效果。前端很重要。至少视觉需要统一！&lt;/p&gt;

</description>
        <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/05/05/inspired/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/05/05/inspired/</guid>
        
        
        <category>Reading</category>
        
      </item>
    
      <item>
        <title>怎么用gitpages还能藏住秘密</title>
        <description>&lt;p&gt;我们用gitpages写博客，但假设，你想把他当做笔记来使用，有些内容并不希望公开，别人看不了，只有你能看，该怎么办呢？&lt;/p&gt;

&lt;p&gt;最直接的，我们想到，需要输入一个密码，才可以看到相应的内容。但整个gitpages是全静态的。你的密码以及验证程序不可避免的明文下载到浏览器端。即使做一个js代码混淆，基本上还是掩耳盗铃。&lt;/p&gt;

&lt;p&gt;某天偶然发现一个叫static crypt的东西，他号称能用密码保护一个html。 &lt;a href=&quot;https://robinmoisson.github.io/staticrypt/&quot;&gt;https://robinmoisson.github.io/staticrypt/&lt;/a&gt; , 他基于&lt;a href=&quot;https://github.com/brix/crypto-js&quot;&gt;https://github.com/brix/crypto-js&lt;/a&gt; ，用 AES-256加密你的html文件，然后把加密过的内容发送到浏览器端，浏览器看到的是一个密码输入框，输入密码，解密，把解密后的html显示出来。大功告成！这个东西还提供命令行版本和npm模块支持。这就方便了我们和gitpages以及jekyll结合。&lt;/p&gt;

&lt;p&gt;首先，确定什么东西是秘密的，不想让人看见，不能push到github的。&lt;/p&gt;

&lt;h4 id=&quot;笔记原文&quot;&gt;&lt;strong&gt;笔记原文&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;正常情况下，文章已md格式放在_posts 或 _drafts 下。但是我们的笔记，应该不能用原文md push到github上。不然人家直接去github看就好了。为了方便起见，我们在 _posts 文件夹下建一个s文件夹。方便加入 .gitignore 和脚本操作&lt;/p&gt;

&lt;h4 id=&quot;秘钥&quot;&gt;秘钥&lt;/h4&gt;

&lt;p&gt;AES是对称加密方法。秘钥，也是我们在浏览器上看笔记时要输入密码，所以这个东西不能push上去简直是废话。&lt;/p&gt;

&lt;p&gt;那如何做到不把这些东西放上去，我们还能在浏览器上看到我们的笔记呢？&lt;/p&gt;

&lt;p&gt;1、首先，我们在网站的更目录里新建一个叫s的文件夹。方便我们找到所有加密过的笔记。&lt;/p&gt;

&lt;p&gt;2、写一个脚本 crypt_posts.sh ; 首先这个脚本调用jekyll  bilud。将我们的笔记md源文件编译成带样式的html；然后对这些html挨个调用staticrypt对其加密(秘钥也在这个文件里制定)；再然后将加密生成的文件替换掉原来编译出来的带明文信息的文件。最后，在这个过程中，可生成一个index.html。 方便在访问${domain}/s 时提供加密文件的索引。当然，这个文件必须加入 .gitignore列表&lt;/p&gt;

&lt;p&gt;3、额，没有第三步，好尴尬~&lt;/p&gt;

</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/04/15/password-protect-a-static-html-page/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/04/15/password-protect-a-static-html-page/</guid>
        
        <category>前端加密</category>
        
        
      </item>
    
      <item>
        <title>简历</title>
        <description>&lt;h3 id=&quot;赖晨东&quot;&gt;赖晨东&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;基本信息&lt;/strong&gt;：2005-2009 赣南师范大学  网络工程  本科 / 江西 / 87年7月&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;联系方式&lt;/strong&gt;：185 0137 8261(微信同号) / laichendong@gmail.com&lt;/p&gt;

&lt;h3 id=&quot;工作经历&quot;&gt;工作经历&lt;/h3&gt;

&lt;h4 id=&quot;20123---now----京东商城---技术经理&quot;&gt;2012.3 - now()    京东商城   技术经理&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;阶段一：2012.3 - 2016.8 程序员、架构师&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为个人贡献者，主要负责京东pop商品相关系统的研发工作，见证和亲历了京东商品从万级到十亿级系统架构的演进。负责的商品中心系统在15年已能达到读20亿/天， 写3亿/天。对分布式系统，并发和异步化有一定的理解。对京东商品，图片，价格，库存等体系的系统架构熟悉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阶段二：2014.8 - now() 技术经理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从14年下半年开始带人。除pop商品以外，还负责过：促销，优惠券，用户营销等业务和系统。最近一年All In在平台治理相关的业务和系统。主要负责构建商家信用体系，商品审核和品控，平台规则和商家奖惩三大模块。技术实现多依赖大数据分析和建模。目前团队成员40人，分别有算法，BI，后端，前端等角色。&lt;/p&gt;

&lt;h4 id=&quot;20119---20123--顺丰优选--后端研发&quot;&gt;2011.9 - 2012.3  顺丰优选  后端研发&lt;/h4&gt;

&lt;p&gt;负责搭建了基于Solr的商品搜索引擎。在优选半年多，当时网站还没上线，整体采用后端java服务，前端php的结构。我作为第一个java研发，在明确了商品基本结构后，搭建了一个分布式的solr集群。这期间技术输入较少。&lt;/p&gt;

&lt;h4 id=&quot;20107---20119-新媒传信--后端研发&quot;&gt;2010.7 - 2011.9 新媒传信  后端研发&lt;/h4&gt;

&lt;p&gt;来北京的第一份工作。负责千腾网（一个特产垂直电商网站，目前已停止运营）研发。开始接触大量互联网技术，包括运维，负载均衡，缓存，消息队列等等。是构建自身技术体系的一份工作，收获很多。&lt;/p&gt;

&lt;h3 id=&quot;技能栈与自我评价&quot;&gt;技能栈与自我评价&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;理解常见互联网架构：分布式，并发，异步，弹性……。抽象思维强，能进行架构设计并编码实现。&lt;/li&gt;
  &lt;li&gt;了解大数据和AI体系，了解Hadoop体系里离线和实时数据处理相关技术栈，了解常用AI算法和有一定的统计学常识。&lt;/li&gt;
  &lt;li&gt;良好的产品感和业务理解能力。能迅速理解业务场景并抽象成可扩展的产品模型。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 28 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/02/28/lcd/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/02/28/lcd/</guid>
        
        
      </item>
    
      <item>
        <title>你把公司当什么</title>
        <description>&lt;h1 id=&quot;你把公司当什么&quot;&gt;你把公司当什么&lt;/h1&gt;

&lt;p&gt;我把公司当什么？当公司啊。那公司又是什么呢？每个人在潜意识里，都会把公司当成自己熟悉的某种场景或概念。这其实就是自己的定位。&lt;/p&gt;

&lt;p&gt;一、 当战场&lt;/p&gt;

&lt;p&gt;认为公司是丛林法则，弱肉强食，&lt;strong&gt;胜过别人才能活下来&lt;/strong&gt;。所以这种人注重竞争，对自己和对队友的要求高。往往看起来职业素养很好。但问题是，这种人可能会有比较强的“地盘意识”，缺乏合作精神。这种人也会有一个典型的苦恼。“同事是个猪队友，总是拖我后腿”&lt;/p&gt;

&lt;p&gt;二、当游乐场&lt;/p&gt;

&lt;p&gt;这种人是希望把工作和兴趣统一的人。工作就是为了兴趣和喜悦。&lt;/p&gt;

&lt;p&gt;“我不喜欢现在的工作怎么办？”“全是杂活，没意思怎么办？”&lt;/p&gt;

&lt;p&gt;但把公司当战场的人是不会想这些问题的，他们想的是如何生存下来，生存得更好。&lt;/p&gt;

&lt;p&gt;三、当贩卖机&lt;/p&gt;

&lt;p&gt;贩卖机是什么呢，就是你扔进去几块钱，就给你出多少钱的东西。认为我给公司时间，公司给我钱。等价交换，两不相欠。如果我付出的少，得到的多，就是赚了。如果我付出的多得到的少，就是亏了。&lt;/p&gt;

&lt;p&gt;这种人的问题主要是在实际中很难找到那个平衡点。苦恼往往是“老板偏心怎么办？”，“我感觉自己付出的多，得到的少”&lt;/p&gt;

&lt;p&gt;四、当学校&lt;/p&gt;

&lt;p&gt;把公司当学校的人，其实是要求进步和要求成长的。这种人最大的困扰是什么呢？往往是”在这个公司我学不到东西怎么办？”&lt;/p&gt;

&lt;p&gt;五、当秀场&lt;/p&gt;

&lt;p&gt;秀场，啊，让我想起了维密，那么多美好的肉体。秀场就是用来展现自我，获得成就感的地方。所以他们会纠结的是 “我辛苦做出的成果，功劳怎么记到老板身上。”“我感觉工作没成就感怎么办？” 如果你把公司当秀场，那自然就不会太喜欢幕后的工作。因为，站在舞台上，聚光灯下才是秀。&lt;/p&gt;

&lt;p&gt;没有绝对的对错和高下之分。但互相合作的人，价值观应该趋同。否则就会产生冲突。比如，我哪天骂你说“麻蛋，你把公司当什么啊？”我是在骂你定位错了吗？不是的，我骂的只是你的定位和我的定位不一样。假设，我把公司当战场，你把公司当游乐场。我就会觉得你幼稚，任性。&lt;/p&gt;

&lt;p&gt;同事之间也一样。你可能会觉得某人太现实，只做分内的事儿，其他事儿一概不管，那他可能只是把公司当贩卖机。你也可能会觉得某个人太讨厌，工作狂，周六的半夜给你打电话催工作。那是他把公司当战场。&lt;/p&gt;

&lt;p&gt;所以，只是定位不同，价值观不同，没有谁对谁错。&lt;/p&gt;

&lt;p&gt;那我把公司当什么呢？在我看来，京东是一个学校+秀场的结合体。很多鸡汤文都说，公司不是学校。老板付你钱不是让你来学习的。但我不是完全同意。我说我们团队18年关键词是成长。就是希望大家来一次京东。聚到我们这个团队，不会白来，这个团队能给你带来成长。我也多次说过，我一直在京东的原因之一就是我觉得身边有很多厉害的人，京东的成长速度大于我自己的成长速度。我还能学到东西。  那秀场呢？的确。公司不是学校。他不能光做慈善机构。那在我们擅长的领域，我们之前学到东西，我们就应该秀出来。输出自己的价值，给公司创造利润，同时收获我们自己的成就感和物质报酬。&lt;/p&gt;

&lt;p&gt;最后，我想让大家想想，你把公司当什么？工作中有哪些事儿是由于价值观和定位不一样导致的冲突，如果，我换个定位，问题还有吗？ 可以就想想，有可以有想法了之后和我喝杯咖啡，单独聊聊。&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/02/28/what-do-you-think-of-the-company/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/02/28/what-do-you-think-of-the-company/</guid>
        
        <category>工作</category>
        
        <category>思维</category>
        
        
      </item>
    
      <item>
        <title>思维模式决定了我们的眼界</title>
        <description>&lt;h1 id=&quot;思维模式决定了我们的眼界&quot;&gt;思维模式决定了我们的眼界&lt;/h1&gt;

&lt;p&gt;https://book.douban.com/subject/30327868/&lt;/p&gt;

&lt;p&gt;是哥伦比亚大学一篇教育学专业的博士生论文，用漫画的方式呈现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;社会给每个人固定的角色，我们被分门别类，放置在轨道上接受指令，按部就班的过完平面化的一生。单一的视角，狭隘而僵化的思维，使我们无法突破自己的局限，无限的潜能也被遏制，我们如同《平面国》中的居民，从不理解更高维度的存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;平面&quot;&gt;平面&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;人们被塞进统一化的凹槽里，大家因此形成了可互换的个体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;人这种活力四射的生物本应该有更多的潜能，现在却抑制自我，疲于行动，空余单调的“平面”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;平面国&quot;&gt;平面国&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;人们已退化至已确立的话语和行为领域&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;发现全新的视角，为各种可能性开拓空间，为觉醒和复苏寻找“全新的方法”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;想找到不同的观察方式，就要从对“所见”的思考开始&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多视角观察的重要性&quot;&gt;多视角观察的重要性&lt;/h2&gt;

&lt;p&gt;两只眼睛因为视角有不同，看到的东西有略微差别。结合起来才看到立体的东西&lt;/p&gt;

&lt;p&gt;狗在黑夜中可以在树林中穿行，除了视觉，更多的依靠嗅觉。比人只靠视觉拥有了更多的维度&lt;/p&gt;

&lt;h2 id=&quot;我们的思维方式&quot;&gt;我们的思维方式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;语言是我们整理经验和形成思想体系的工具，使我们吸入的氧气和赖以生存的海洋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们是自身所继承的语言的囚徒，这种语言嵌入了祖先的思维模式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;思维模式决定了眼界&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;漫画，兼具文字和图像，兼具连续性和零散性，是一种很好的突破限制的工具。&lt;/p&gt;

&lt;h2 id=&quot;运动的身体&quot;&gt;运动的身体&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;理解是抓住；绘画是一种精心编排的自我交流方式。绘画不是用手转录头脑中的想法，而是为了追寻更深层次的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;并不存在一种单一而客观的视角。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;第五维度&quot;&gt;第五维度&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;事实上，在我们看不见的地方有着无限的可能性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;想象力让我们突破难以跨越的界限，发现不存在或者说存在于无法接触的维度里的认知&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;以多重世界作为参考框架，可以看到同个世界的不同面，让熟悉的东西变得陌生，穿过这些门，改变的可能性便出现了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;陈规&quot;&gt;陈规&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;涓流汇成小溪，附庸者聚集在一起，力量不断加强，我们走在前人走过的路上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;每个人都会加入一条存在已久，似乎本该如此的队伍&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;刚开始不适应的事情，很快就变成了第二本能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每天走不同的路线去上班！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管雨会一直下，陈规也会一直不断出现。但我们必须歌唱，跳舞，寻找逃离的办法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;系着的线&quot;&gt;系着的线&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;每天，他都像发条装置一般，忠实地遵循着自己的日常行为模式。他在该醒来的时候醒来，该吃饭的时候吃饭。他出色且高效的扮演着自己的角色，一直如此，并且还会继续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;航向&quot;&gt;航向&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;想放飞自我，不能简单的割断系线，因为摆脱他们只会让我们漂泊无依，失去那些成就我们的东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;解放，不是脱离束缚，而是找到更好的依靠。&lt;/p&gt;

  &lt;p&gt;我们应该保留这些绳子，认清这些附属物并非限制，而是可以利用的力量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;觉醒&quot;&gt;觉醒&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们时常陷入一个陷阱，认为你的成长和你的未来是受外部环境影响而不是有自己掌握。认为你的思想一定是别人给予的。你没有意识到其实你自始至终都不需要别人给与你什么，你得自己找到他。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 14 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/02/14/unflattening/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/02/14/unflattening/</guid>
        
        <category>思维模式</category>
        
        <category>尝试</category>
        
        
      </item>
    
      <item>
        <title>2019-flags</title>
        <description>&lt;h4 id=&quot;自我修炼--兴趣爱好&quot;&gt;自我修炼 &amp;amp; 兴趣爱好&lt;/h4&gt;

&lt;h5 id=&quot;看书&quot;&gt;看书：&lt;/h5&gt;
&lt;p&gt;总数：6/9/12 本 
追踪豆瓣读书，把2019年最受关注的书读了！&lt;/p&gt;

&lt;p&gt;《非平面》-眼界觉得高度&lt;/p&gt;

&lt;p&gt;《文明之光》&lt;/p&gt;

&lt;p&gt;《启示录-打造用户喜爱的产品》&lt;/p&gt;

&lt;h5 id=&quot;摄影&quot;&gt;摄影：&lt;/h5&gt;
&lt;p&gt;买一个定焦镜头（55 1.8？），在图虫上发照片，&lt;strong&gt;系统的学习一下人像摄影&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;跑步&quot;&gt;跑步：&lt;/h5&gt;
&lt;p&gt;总里程：300/500/700 km&lt;/p&gt;

&lt;p&gt;2019年04月15日：93km&lt;/p&gt;

&lt;p&gt;报名并完成一次半马&lt;/p&gt;

&lt;h5 id=&quot;游泳&quot;&gt;游泳：&lt;/h5&gt;
&lt;p&gt;能一口气完成50m蛙泳
踩水10分钟以上
学会自由泳姿势&lt;/p&gt;

&lt;h4 id=&quot;生活&quot;&gt;生活：&lt;/h4&gt;

&lt;h5 id=&quot;旅行-&quot;&gt;旅行 ：&lt;/h5&gt;
&lt;p&gt;一次出国旅行，带上儿子上一次高原&lt;/p&gt;

&lt;h5 id=&quot;资产增长&quot;&gt;资产增长：&lt;/h5&gt;
&lt;p&gt;天津买房：总价110以内。中上学区  or  外围新房120以上
摇到号换车：总价40W左右   glc 260&lt;/p&gt;

&lt;h4 id=&quot;工作&quot;&gt;工作：&lt;/h4&gt;

</description>
        <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2019/01/01/2019-flags/</link>
        <guid isPermaLink="true">http://laichendong.com/2019/01/01/2019-flags/</guid>
        
        <category>OKR</category>
        
        
      </item>
    
      <item>
        <title>Sequence Generator</title>
        <description>&lt;h1 id=&quot;sequence唯一id-生成器&quot;&gt;Sequence（唯一id） 生成器&lt;/h1&gt;

&lt;p&gt;在如今的分布式场景下，MySql分库分表非常常见。我们不能用MySql的auto increment字段，这是单表的。我们需要保证一个逻辑表的若干物理表里的数据的主键互相不重复。因为如果存在重复的情况，当物理表扩容或缩容导致数据移动并进一步导致两条拥有相同ID的数据进入到一张表里时，就会造成主键冲突。所以，我们需要一个全局的，高性能的唯一主键生成器。&lt;/p&gt;

&lt;p&gt;GUID 或UUID 貌似就符合这个要求！但是，一来这类id不是数字的，生成不具有全局顺序性。二来，也是因为不是数字的，做MySql的主键，性能不如数字。所以，虽然生成的成本很低，也要放弃这个方案。&lt;/p&gt;

&lt;p&gt;我们的方案是，在数据库中持久化一个数值，表示当前ID增长到了哪，要获取下一个ID时则带条件的去更新这个值为&lt;code class=&quot;highlighter-rouge&quot;&gt;当前值+1&lt;/code&gt;（乐观锁），如果更新成功，则认为获取到了新的ID，如果不成功，则再试到成功为止。进一步的，为了在逻辑表和应用服务器都比较多的情况下，降低持有这个值的表过热，乐观锁碰撞过多的情况。允许每个应用服务器持有一个容量为n的ID块，然后n次内的ID获取在应用服务器内同步的完成，第n次获取，才向数据库发一次update操作，修改数据库从+1变成+n。大概示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcly1fs1kchrygtj310l0tsjxt.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面来详细看下实现&lt;/p&gt;

&lt;p&gt;首先，由于上面提到的应用服务器内持有一个容量为n的id块，我们设计了一个内部类Step来实现这个功能。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 当前值，调用incrementAndGet()返回下一个id&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 当前块的结束值，限定Step的容量&lt;/span&gt;

    	&lt;span class=&quot;c1&quot;&gt;// 初始化时  endValue - currentValue = n   (blockSize)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;endValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setCurrentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setEndValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;endValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      
        &lt;span class=&quot;c1&quot;&gt;// 因为这个方法 外面是在同步块里调用的，所以这里没用synchronize，&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// currentValue 也没用 AtomicLong&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;incrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再看Sequence类：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 容量或者叫步长，一次从数据库中获取多少个ID&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// id从几开始涨，在已有数据要迁移的情况下，可以设置为非零的数&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 每个表一个Step，这个map持有了所有表的Step引用&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 外面是同步的  所以也不用concurrentHashMap&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stepMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 持有数据源和三条sql。用于持久化的表名是写死的：sequence_value&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 数据源通过spring注入&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DataSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GET_SQL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;select id from sequence_value where name = ?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NEW_SQL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;insert into sequence_value (id,name) values (?,?)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这条sql里where条件里的id=?很重要，是一个乐观锁机制，防止过程中已经有别的进程(别的Sequence实例)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 对表进行了更新，导致id重复&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPDATE_SQL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;update sequence_value set id = ?  where name = ? and id = ?&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sequence类的唯一入口方法 get的实现：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 这个方法必须是同步的，防止多个线程同时获取同一表的id，导致重复&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stepMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// step == null 表示第一次获取这个表的id，后面的逻辑会继续走，从数据库中读入&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 直接new一个Step放到map里备用，下次就能走else里的逻辑了&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stepMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 当前块还没用完，直接内存里返回下一个ID就好&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 否则的话，表示当前块里id用完了，继续走下面的从数据库中获取的逻辑&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;endValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//默认为0和0，所以没有错&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;incrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;// 尝试blockSize次 从数据库获取下一个块&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getNextBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//  一旦获取到，就直接内存里返回，不用再getNextBlock了&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;incrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;// 尝试了若干次都失败了，只能抛异常出去&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No more value.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再看看从数据库中获取下一个块的实现是怎么样的。其实从上面看到的3条sql基本上就已经了解得7788了。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNextBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Step&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;c1&quot;&gt;// 发select语句，获取库里当前值&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPersistenceValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 如果没有，就初始化， 发insert语句，&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// insert的值是上面配置的 startValue, 默认为0， 返回的是刚插入的值&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPersistenceValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 如果初始化失败，说明有程序先初始化了，(别的进程也同时对这个表进行id获取)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 这里需要对sequence_value表的name字段做唯一索引限制。否则会有问题&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 可能两个进程同时插入了两条name相同的数据&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;newPersistenceValue error!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPersistenceValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 发update语句，申请下一个块，将库里的值update为 value+blockSize ，&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这样，这个进程里的请求就能直接内存返回&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 而别的进程 去getNextBlock时，会改成更大的值，&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 比如A进程持有的是 0-5， B进程持有的是 6-10&lt;/span&gt;
     	&lt;span class=&quot;c1&quot;&gt;// 这条update语句是带条件更新的，前面已经有提到，也是为了防止并发产生id重复&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 因为带条件更新可能失败， 所以 如果失败，外面的get方法要进行重试。 策略是重试blockSize次&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 成功获取到下一个块了，更新step对象，后面就可以用step.incrementAndGet()了。&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCurrentValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEndValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到此，Sequence的核心实现就完成了。&lt;code class=&quot;highlighter-rouge&quot;&gt;getPersistenceValue&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;newPersistenceValue&lt;/code&gt;  &lt;code class=&quot;highlighter-rouge&quot;&gt;saveValue&lt;/code&gt; 这三个jdbc操作数据库的方法没什么特别的，就不贴出来细看了。&lt;/p&gt;

&lt;p&gt;有些时候，除了我们的主业务表比较大，id需求比较大，需要单独一个Sequence名字，其他很多小表可以共用一个默认的Sequence名字，所以，就又提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;SequenceUtil&lt;/code&gt;类。作为Sequence的一个代理，如果没有对应名字的id序列，就用默认的序列。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SequenceUtil&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequenceMap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequenceMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果从持有的map里没取到这个名字的Sequence的话，就取默认的&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultSequence&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defaultSequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 默认的还没有配置，就抛异常&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RuntimeException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sequence &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; undefined!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 代理到具体的Sequence实例 进行id的get&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequence&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OK，到此为止这个精巧的设计就介绍完了。如果要生成id的表太多，导致Sequence_value表过热，可以把BlockSize调大一些，减少对库的操作次数。甚至可以设置几个不同的实例，连接不同的数据源。 这个设计有一个需要注意的地方，就是生成的id是大体上全局有序的，但不是严格有序的。比如A实例持有该1-5，B实例持有6-10。生成的id可能是&lt;code class=&quot;highlighter-rouge&quot;&gt;1，6，2，7……&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;都看到这了，说明是真爱！那就给个赠品吧。flickr的Ticket Server设计。这我们这个设计有许多相似之处。供参考：http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2018/08/06/sequence-generator/</link>
        <guid isPermaLink="true">http://laichendong.com/2018/08/06/sequence-generator/</guid>
        
        
      </item>
    
      <item>
        <title>收益率，年化收益率，年利率，日息，三分利傻傻分不清楚</title>
        <description>&lt;p&gt;现在互联网理财的东西实在太多了，而各种概念对于我这种资质愚钝的人来说也是傻傻分不清楚，帮自己整理记录一下。&lt;/p&gt;

&lt;h2 id=&quot;本金&quot;&gt;本金&lt;/h2&gt;

&lt;p&gt;本金好说，就是你投进去的真金白银。一般计为&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;收益&quot;&gt;收益&lt;/h2&gt;

&lt;p&gt;收益也好说，就是用投资结束时拿到的钱&lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;减去当初的本金。所以收益&lt;code class=&quot;highlighter-rouge&quot;&gt;P= V-C&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;收益率&quot;&gt;收益率&lt;/h2&gt;

&lt;p&gt;所以收益率就比较好理解了，就是收益占本金的比例。收益率&lt;code class=&quot;highlighter-rouge&quot;&gt;K= P/C= (V-C)/C = V/C -1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里注意，这个收益率前面是没有时间定语的。而像余额宝之类的产品里面说的“近七天年化收益率”则不是这个概念。&lt;/p&gt;

&lt;h2 id=&quot;年化收益率&quot;&gt;年化收益率&lt;/h2&gt;

&lt;p&gt;所谓年化收益率，是指的按现在的收益率来算（比如余额宝的7天），不出意外的话，一年投资下来，能获得的收益率。就是说，这个值是个大概的值，估计的值。举个例子来说，往余额宝里放了10000块，过了7天，赚了9块，那余额宝的&lt;code class=&quot;highlighter-rouge&quot;&gt;近七天年化收益率=((投资内收益/本金)/投资天数)*365×100%= ((9/10000)/7)*365*100%=4.69%&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;年收益率&quot;&gt;年收益率&lt;/h2&gt;

&lt;p&gt;年收益率比刚才少了个化字。这个概念和收益率是一样的，不是估算，是事实。比如，存10000块到银行，5年定期，5年后得到12375块，那&lt;code class=&quot;highlighter-rouge&quot;&gt;年收益率= 收益率/N = (12375/10000 -1)/5=4.75%&lt;/code&gt;  这个4.75%就是银行5年定期的利率。&lt;/p&gt;

&lt;h2 id=&quot;日息&quot;&gt;日息&lt;/h2&gt;

&lt;p&gt;除了赚钱，还有借钱，比如京东金条说“1000借一天，利息0.25元”，那一天的利率=0.25/1000=万分之2.5 。按单利来算，一年的利率 = 日息 * 365 = 9.1%。如果是按复利计算，会更高。除了这种平台借钱，民间借钱说利息一般都说几分利或几厘利。&lt;strong&gt;1分=10厘，1元=10角=100分=1000厘&lt;/strong&gt;，如果说“三分利”换算成年利率是多少呢？如果没有特别说明的话，三分利指的是一块钱借一个月的利息为3分钱。即月利率3%。那年利率= 月利率 * 12 = 3% * 12 = 36%！真是高利贷啊！1分利就是年利率12%。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;互联网借款平台&lt;strong&gt;日息万3&lt;/strong&gt;，余额宝&lt;strong&gt;近七日年化5%&lt;/strong&gt;，民间借贷&lt;strong&gt;1分利&lt;/strong&gt;，央行5年以上贷款基准利率&lt;strong&gt;4.9%&lt;/strong&gt;。这几个谁搞谁低呢？首先，统一换算成年利率。年化！&lt;/p&gt;

&lt;p&gt;日息万3 = 年化 3/10000 * 365 =  10.95%；余额宝直接就是年化5%； 1分利上面算过了，年化12%； 而央行贷款利率也就是指的年化利率4.9%。这就比较清楚了。这么看，央行的基准贷款利率其实还是挺低的，就是银行按基准利率把钱贷给你和你把钱放到余额宝的收益是差不多的。&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://laichendong.com/2018/02/24/interest-rate/</link>
        <guid isPermaLink="true">http://laichendong.com/2018/02/24/interest-rate/</guid>
        
        <category>理财</category>
        
        <category>收益计算</category>
        
        
      </item>
    
  </channel>
</rss>
